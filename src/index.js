/**
 * Class containing information and logic needed to generate a brief
 * string description of input values.
 */
class Describe {
    constructor(descriptors) {
        this.descriptors = descriptors || [];
    }
    
    /**
     * Internal helper for generating a safe representation of
     * an arbitrary string value. Special characters (including
     * newlines and escape characters) will be escaped and
     * long strings will be truncated.
     */
    getSafeString(length, value) {
        let i = length - 2;
        let j = 4;
        while(i >= 4) {
            const trunc = (value.length <= i ?
                value : value.slice(0, i - 3) + "..."
            );
            const escaped = JSON.stringify(trunc);
            if(escaped.length <= length) {
                return escaped;
            }
            i -= j;
            j += 2;
        }
        return "";
    }
    
    /**
     * Internal helper for safely getting the class name string
     * of an arbitrary object.
     */
    getClassName(value) {
        if(!value || typeof(value) !== "object") {
            return undefined;
        }
        const prototype = Object.getPrototypeOf(value);
        if(!prototype) {
            return null;
        }
        const constructor = Object.getOwnPropertyDescriptor(
            prototype, "constructor"
        );
        if(!constructor || typeof(constructor.value) !== "function") {
            return undefined;
        }
        const name = Object.getOwnPropertyDescriptor(
            constructor.value, "name"
        );
        if(name && typeof(name.value) === "string") {
            return name.value;
        }
        else {
            return undefined;
        }
    }
    
    /**
     * Add a custom descriptor function to be used by `describe`.
     *
     * @param descriptor A function accepting an arbitrary value
     * and returning a brief string description of that value,
     * or a falsey value if it was not applicable and another
     * descriptor should be tried instead.
     */
    addDescriptor(descriptor) {
        this.descriptors.push(descriptor);
    }
    
    /**
     * Get a string briefly describing a value.
     * Custom descriptions can be generated by using the addDescriptor
     * function.
     *
     * @param value The value to describe.
     * @returns A string briefly describing the input value.
     */
    describe(value) {
        for(const descriptor of this.descriptors) {
            const result = descriptor(value);
            if(result) {
                return String(result);
            }
        }
        if(value === undefined) {
            return "undefined";
        }
        else if(value === null) {
            return "null";
        }
        else if(value === false) {
            return "a false boolean value";
        }
        else if(value === true) {
            return "a true boolean value";
        }
        else if(typeof(value) === "number") {
            if(Number.isNaN(value)) {
                return "NaN";
            }
            else if(value === Infinity) {
                return "positive infinity";
            }
            else if(value === -Infinity) {
                return "negative infinity";
            }
            else if(value === 0) {
                return "the number 0";
            }
            else if(Number.isInteger(value)) {
                return "the integer " + String(value);
            }
            else {
                return "the number " + String(value);
            }
        }
        else if(typeof(value) === "bigint") {
            if(value == 0) {
                return "the bigint number 0n";
            }
            else if(value <= Number.MAX_SAFE_INTEGER && value >= -Number.MAX_SAFE_INTEGER) {
                return "the bigint number " + String(value) + "n";
            }
            else {
                const sign = value > 0 ? "positive" : "negative";
                return "a " + sign + " bigint number";
            }
        }
        else if(typeof(value) === "string") {
            if(!value.length) {
                return "an empty string";
            }
            else if(value.length <= 32) {
                const valueString = JSON.stringify(value);
                if(valueString.length <= 48) {
                    return "the string " + valueString;
                }
                else {
                    return "a string";
                }
            }
            else {
                return "a string";
            }
        }
        else if(typeof(value) === "symbol") {
            return String(value.description.slice(0, 60));
        }
        else if(Array.isArray(value)) {
            const length = Object.getOwnPropertyDescriptor(value, "length");
            if(Object.getPrototypeOf(value) !== Array.prototype || !length || (
                 length.get !== Object.getOwnPropertyDescriptor([], "length").get
            )) {
                return "an array";
            }
            else if(!value.length) {
                return "an empty array";
            }
            else if(value.length === 1) {
                return "an array with 1 element";
            }
            else {
                return "an array with " + String(value.length) + " elements";
            }
        }
        else if(typeof(Set) !== "undefined" && value instanceof Set) {
            if(Object.getPrototypeOf(value) !== Set.prototype ||
                Object.getOwnPropertyDescriptor(value, "size")
            ) {
                return "a set";
            }
            else if(!value.size) {
                return "an empty set";
            }
            else if(value.size === 1) {
                return "a set with 1 element";
            }
            else {
                return "a set with " + String(value.size) + " elements";
            }
        }
        else if(typeof(Map) !== "undefined" && value instanceof Map) {
            if(Object.getPrototypeOf(value) !== Map.prototype ||
                Object.getOwnPropertyDescriptor(value, "size")
            ) {
                return "a map";
            }
            else if(!value.size) {
                return "an empty map";
            }
            else if(value.size === 1) {
                return "a map with 1 key";
            }
            else {
                return "a map with " + String(value.size) + " keys";
            }
        }
        else if(typeof(Buffer) !== "undefined" && value instanceof Buffer) {
            if(Object.getPrototypeOf(value) !== Buffer.prototype ||
                Object.getOwnPropertyDescriptor(value, "length")
            ) {
                return "a buffer";
            }
            else if(!value.length) {
                return "an empty buffer";
            }
            else if(value.length === 1) {
                return "a buffer containing 1 byte";
            }
            else {
                return "a buffer containing " + String(value.length) + " bytes";
            }
        }
        else if(typeof(Promise) !== "undefined" && value instanceof Promise) {
            return "a promise";
        }
        else if(typeof(value) === "object" && value) {
            const prototype = Object.getPrototypeOf(value);
            if(prototype === Object.prototype) {
                let count = 0;
                for(const key in value) {
                    count += (
                        Object.prototype.hasOwnProperty.call(value, key) ?
                        1 : 0
                    );
                }
                if(count === 0) {
                    return "an empty object";
                }
                else if(count === 1) {
                    return "a plain object with 1 key";
                }
                else {
                    return "a plain object with " + String(count) + " keys";
                }
            }
            else {
                const className = this.getClassName(value);
                if(className) {
                    const safeName = this.getSafeString(36, className);
                    return (safeName ?
                        "an object instance of " + safeName :
                        "an object instance"
                    );
                }
                else if(typeof(Symbol) !== "undefined" &&
                    Symbol.iterator in value
                ) {
                    return "an iterable object";
                }
                else {
                    return "an object";
                }
            }
        }
        else if(typeof(value) === "function") {
            if(value.name) {
                const funcName = this.getSafeString(40, value.name);
                return (funcName ?
                    "the function " + funcName :
                    "a function"
                );
            }
            else {
                return "an anonymous function";
            }
        }
        else {
            const typeName = this.getSafeString(32, typeof(value));
            return (typeName ?
                "a value with type " + typeName :
                "a value with an unrecognized type"
            );
        }
    }
}

/**
 * Global default instance of the `Describe` class.
 */
const DefaultDescribe = new Describe();

/**
 * Add a custom descriptor function to be used by `describe`.
 *
 * @param descriptor A function accepting an arbitrary value
 * and returning a brief string description of that value,
 * or a falsey value if it was not applicable and another
 * descriptor should be tried instead.
 */
function addDescriptor(descriptor) {
    DefaultDescribe.addDescriptor(descriptor);
}

/**
 * Get a string briefly describing a value.
 * Custom descriptions can be generated by using the addDescriptor
 * function.
 *
 * @param value The value to describe.
 * @returns A string briefly describing the input value.
 */
function describe(value) {
    return DefaultDescribe.describe(value);
}

module.exports = {
    Describe: Describe,
    DefaultDescribe: DefaultDescribe,
    addDescriptor: addDescriptor,
    describe: describe,
    default: describe,
};
